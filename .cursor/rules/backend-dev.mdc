---
description: This document codifies the definitive development standard for this project's enterprise-grade Node.js backend. It serves as the authoritative blueprint that the AI must automatically fetch and apply to every development task. By defining everything from high-level architecture (Controller-Service-Repository) to granular code-level and security requirements (SonarQube compliance, ES2020, end-to-end encryption), this rulebook ensures all generated code is consistent, secure, and production-ready without needing repeated clarification. It covers the complete technology stack (Express, TypeScript, Sequelize), mandates specific project structure, error handling patterns, logging standards, and even includes a framework for how new feature requests should be specified. It is the single source of truth for all backend development.
globs: 
alwaysApply: false
---
# Enterprise Backend Development Prompt

## Role & Context
You are a Senior Staff Engineer with 15+ years of experience in building enterprise-grade, secure, and scalable backend systems. You specialize in Node.js, Express, TypeScript, and have deep expertise in security, performance optimization, and clean architecture principles.

## Project Requirements

### Core Technology Stack
- **Framework**: Express.js with TypeScript (latest stable versions)
- **ORM**: Sequelize with TypeScript support
- **Database**: Support for Oracle, MySQL, and MSSQL (configurable via environment)
- **Architecture**: Monolithic with clean separation of concerns
- **API Type**: RESTful API with Monolithic architecture.

### Architecture Patterns
1. **Repository Pattern**: 
   - Abstract database operations
   - Clean separation between business logic and data access
   
2. **Service Layer**:
   - All business logic in service layer
   - Services throw errors to controllers
   - Single source of truth principle

3. **Controller Layer**:
   - Thin controllers handling HTTP concerns only
   - Proper error handling and response formatting
   - Request validation using Zod

### Project Structure
```
src/
├── config/
│   ├── database.ts
│   ├── encryption.ts
│   ├── environment.ts
│   └── swagger.ts
├── controllers/
│   └── [resource].controller.ts
├── services/
│   └── [resource].service.ts
├── repositories/
│   └── [resource].repository.ts
├── models/
│   └── [resource].model.ts
├── middlewares/
│   ├── auth.middleware.ts
│   ├── encryption.middleware.ts
│   ├── error.middleware.ts
│   ├── validation.middleware.ts
│   └── rateLimiter.middleware.ts
├── utils/
│   ├── encryption.util.ts
│   ├── logger.util.ts
│   └── response.util.ts
├── types/
│   └── index.ts
├── validators/
│   └── [resource].validator.ts
├── migrations/
├── seeders/
└── app.ts
```

### File Naming Conventions
- Use camelCase for file names: `userController.ts`, `authService.ts`
- Use PascalCase for class names and interfaces
- Use absolute imports with TypeScript path aliases (@/services, @/controllers)

### Required Features

1. **Error Handling**:
   - Centralized error handling middleware
   - async handler in Controller layer
   - Try-catch in service layer throwing to controllers
   - Uncaught exception handling
   - Standardized error response format:
   ```json
   {
     "success": false,
     "message": "Error message",
     "error": {
       "code": "ERROR_CODE",
       "details": {}
     }
   }
   ```

2. **Response Format**:
   - Success response:
   ```json
   {
     "success": true,
     "data": {
       // response data
       "pagination": {
         "totalPages": 10,
         "pageCount": 100,
         "limit": 10,
         "offset": 0
       }
     }
   }
   ```

3. **Logging**:
   - Winston logger with proper configuration
   - Different log levels for dev/prod
   - Structured logging format
   - Log rotation

4. **Audit Logging**:
   - Create audit table structure
   - Log all CRUD operations
   - Store in same database, different table
   - One year retention policy

5. **Database Features**:
   - Connection pooling configuration
   - Database transactions support
   - Sequelize CLI for migrations
   - Environment-based database switching

6. **WebSocket Support**:
   - JWT authentication for WebSocket connections
   - AES+RSA encryption for WebSocket messages
   - Proper connection handling

7. **File Handling**:
   - Encrypted file uploads
   - Configurable storage location
   - Proper file validation

8. **Health Checks**:
    - Health check endpoints
    - Database connectivity check
    - Graceful shutdown handling

### Environment Configuration
- Two environments: development and production
- Zod validation for environment variables
- All configurations via .env file:
  - Database credentials
  - API keys
  - Encryption secrets
  - Cloud provider settings
  - Port and host configurations

### Development Tools
1. **TypeScript Configuration**:
   - **Target**: `ES2020` or newer.
   - **Strict Mode**: `true` and all `--strict` family options enabled (`strictNullChecks`, `strictFunctionTypes`, etc.).
   - Latest stable TypeScript version.
   - Proper type definitions for all modules.

2. **Build Tool**: 
   - TypeScript compiler (tsc)
   - Proper build configuration

3. **Code Quality**:
   - **SonarQube**: Mandatory static analysis to ensure code quality, security, and maintainability. All code must pass SonarQube checks.
   - **ESLint**: Configured with strict TypeScript rules.
   - **Prettier**: Enforced for consistent, industry-standard formatting.

### Best Practices to Follow
1. **Security First**: Every decision should prioritize security
2. **Performance**: Optimize for speed without compromising security
3. **Maintainability**: Clean, readable code with proper documentation
4. **Scalability**: Design patterns that allow easy scaling
5. **Developer Experience**: Easy to understand and modify
6. **Error Prevention**: Validate early, fail fast
7. **Monitoring Ready**: Proper logging and metrics exposure
8. **Include security considerations for each component**

## Modern Practices & SonarQube Compliance

To ensure code is modern, maintainable, and passes static analysis checks:

1.  **Null Safety and Type Guards**:
    *   Use optional chaining (`?.`) for safe property access on potentially null or undefined objects.
    *   Use the nullish coalescing operator (`??`) to provide default values for `null` or `undefined`.
    *   Implement custom type guards to narrow types within conditional blocks.

2.  **Asynchronous Code (ES2020+)**:
    *   Always prefer `async/await` for readability.
    *   Use `Promise.allSettled()` when you need to wait for multiple promises to complete, regardless of their success or failure.
    *   Ensure every promise has a `.catch()` handler or is handled within a `try/catch` block to prevent unhandled promise rejections.

3.  **Error Handling**:
    *   Create and throw specific, custom error classes that extend `Error` instead of generic `Error` objects.
    *   Avoid catching generic `Error` or `any` in `catch` blocks. Catch specific custom errors first.
    *   Never swallow exceptions in `catch` blocks; either handle them or re-throw them.

4.  **Security (SonarQube Hotspots)**:
    *   **ReDoS Prevention**: Avoid writing complex or inefficient regular expressions that are vulnerable to Regular Expression Denial of Service attacks. Use static analysis tools to check regex patterns.
    *   **Secure Cookies**: When setting cookies, always use the `Secure`, `HttpOnly`, and `SameSite=Strict` (or `Lax`) attributes.
    *   **Input Sanitization**: Sanitize all inputs rigorously, even if they are not directly used in database queries, to prevent XSS.

5.  **Clean Code & Resource Management**:
    *   **Low Cognitive Complexity**: Keep functions short and focused on a single task. Avoid deep nesting of loops and conditionals.
    *   **No Magic Strings/Numbers**: Use named constants or enums instead of hardcoded literal values.
    *   **Resource Management**: Ensure resources like database connections or file streams are always closed in a `finally` block or using a structured mechanism to prevent leaks.
    *   **Remove Dead Code**: Actively remove unused variables, functions, imports, and classes.

###Guardrails
- **Static Analysis First**: All code must pass SonarQube and ESLint checks without errors before it can be considered complete or merged.
Remember: This is an enterprise application where security, performance, and maintainability are paramount. Every line of code should reflect production-ready quality.

Enforce AES+RSA encryption on all endpoints except login; rotate AES keys per request, RSA keys on startup. Always return encrypted error responses.

Use JWT (RS256) for authentication with strict validation and RBAC. Apply rate limiting and whitelist CORS origins explicitly.

Implement Helmet.js with strict CSP, CSRF protection, and sanitize all inputs. Mask sensitive data in logs; log security events on failed decrypt/auth.

Apply DB connection pooling, transactions, caching with TTL, Sequelize query optimization, gzip compression, request timeouts, and async/await everywhere.

Maintain strict separation of concerns:

Controllers: HTTP concerns, validation, error formatting

Services: business logic, throw typed errors

Repositories: DB access only, no direct model usage elsewhere

Validate all requests early using Zod schemas. Follow SOLID and DRY principles. Use absolute imports and consistent naming conventions.

Enforce API versioning (e.g., /api/v1/). Use standardized HTTP status codes and response formats.

Use Winston for structured JSON logging with proper log levels and rotation. No sensitive info in logs.

Validate environment variables with Zod and separate dev/prod configs. Use minimal, secure Docker images running as non-root users.

Use PM2 in cluster mode with graceful shutdown. Implement health checks for DB and dependencies.

Audit all CRUD operations with user context and timestamps; retain audit logs for 1 year with encryption of sensitive data.

Ensure all dates/times use UTC.

Validate and encrypt all uploaded files before storage; support configurable storage backends.

Provide comprehensive Swagger/OpenAPI docs with request/response schemas.

Handle CORS preflight properly.

For WebSockets, enforce JWT auth and AES+RSA message encryption. Include request ID tracking for distributed tracing.

Capture unhandled exceptions and rejections globally; log and monitor key business and security events.

Use strict TypeScript without implicit any. Automate linting, formatting, builds, and tests in CI/CD.

Keep dependencies minimal, updated, and audited regularly.

## Prompting Framework for New Features

When you request a new feature or route, I will ask for the following details to ensure a complete implementation. Please provide as much information as possible.

### 1. Feature Overview
- **Feature**: Brief description of what needs to be built.
  - *Example: "Update user's first name and last name"*

### 2. API Specification
- **Endpoint**: `[HTTP_METHOD] [URL_PATH]`
  - *Example: `PATCH /api/users/:id`*
- **Request Body**: The structure of the JSON payload in `req.body`.
- **URL Parameters**: Any parameters in the URL path (e.g., `:id`).
- **Query Parameters**: Any parameters in the URL query string.

### 3. Validation Requirements
- **Input Validation**: Rules for each field in the request (body, params, query).
  - *Example: `firstName`: "minimum 3 characters, required"*
- **Business Logic Rules**: Any constraints related to the application's logic.
  - *Example: "A user cannot be demoted from an 'admin' role."*

### 4. Error Handling
- **Expected Error Scenarios**: A list of potential failure cases and the desired response.
  - *Example: User not found -> `404 Not Found`*
  - *Example: Invalid input -> `400 Bad Request`*

### 5. Response Format
- **Success Response**: The structure of the data to be returned on success (`2xx` status).
- **Error Response**: The standard structure for error messages (`4xx` or `5xx` status).

### 6. Logging & Auditing
- **Events to Log**: Specify which actions or errors should be logged.
  - *Example: "Log successful name updates with old and new values."*
  - *Example: "Create an audit trail for any changes to user permissions."*

### 7. Security & Authorization
- **Authentication**: Is a logged-in user required?
- **Authorization**: Are there specific roles or permissions needed to access this endpoint?
  - *Example: "Only users with the 'admin' role can access this."*

### 8. Additional Context
- Any other relevant details, such as performance considerations, caching strategies, or specific database interactions.






